uniform float px_per_m;
uniform float background_px;

uniform shader background_image;
uniform shader background_thumb;

const float3 kDotsColor = float3(0.5, 0.5, 0.5);
const float kPi = 3.1415926535897932384626433832795;

float grid(vec2 coord_m, float dots_per_m, float r_px) {
  float r = r_px / px_per_m;
  vec2 grid_coord = fract(coord_m * dots_per_m + 0.5) - 0.5;
  return smoothstep(r, r - 1 / px_per_m, length(grid_coord) / dots_per_m) * smoothstep(1. / (3 * r), 1. / (32 * r), dots_per_m);
}

// Should return a number between 0 and 1.
// It should return the ratio of the cell area below the given `pos`.
float vx(float2 pos, float a) {
  float l = 1.0 / sqrt(a * a + (1.0 - a) * (1.0 - a));
  float2 uv = pos * mat2x2(a, a - 1, 1 - a, a);
  uv = fract(uv * l) * 2 - 1; // -1 to 1
  float r2 = dot(uv, uv);
  if (r2 <= 1) {
    return kPi * r2 / 4;
  } else {
    return r2 * asin(1 / sqrt(r2)) + sqrt(r2 - 1) - kPi * r2 / 4;
  }
}

// performs halftone dithering
vec3 halftone(vec3 bg, vec3 fg, vec2 coord_px) {
  vec3 bias = vec3(vx(coord_px, 0.12), vx(coord_px, 0.34), vx(coord_px, 0.69));
  vec3 delta = (fg - bg) * 2;
  vec3 mag = abs(delta);

  const float k = 0.03;
  // If mag < k: mag is set 0
  // If mag > 2k: mag is unchanged
  // In between: mag ramps up linearly
  mag = min(mag, max(vec3(0.0), (mag - k) * 2.0));

  vec3 ink = step(0, delta);
  vec3 use_bg = step(mag, bias);

  vec3 biasD = vec3(length(vec2(dFdx(coord_px.x), dFdy(coord_px.y))) * sqrt(mag) * 2);

  vec3 use_ink = smoothstep(bias - biasD, bias + biasD, mag);
  return mix(bg, ink, use_ink);
}

half4 main(vec2 coord_m) {
  // coord_m - a number from -0.5 to 0.5 - coordinate on the canvas, in metric space
  float dm_grid = grid(coord_m, 10, 2);
  float cm_grid = grid(coord_m, 100, 2) * 0.8;
  float mm_grid = grid(coord_m, 1000, 1) * 0.8;
  float d = max(max(mm_grid, cm_grid), dm_grid);

  float3 background_val = background_image.eval(coord_m + 0.5).rgb;

  // background dimensions are 1x1 m so if thre are more px in a meter than bg dimension, then we need to dither
  if (px_per_m > background_px) {
    float3 background_blur = background_thumb.eval(coord_m + 0.5).rgb;

    float3 background_halftone = halftone(background_blur, background_val, coord_m * background_px);

    // halftone pattern appears at `background_px` and is in full effect at `background_px * 4`
    float halftone_blend = smoothstep(background_px, background_px * 4, px_per_m);

    background_val = mix(background_val, background_halftone, halftone_blend);
  }

  return vec4(mix(background_val, kDotsColor, d), 1);
}
