uniform float px_per_m;
uniform float background_px;

uniform shader background_image;

const float3 kDotsColor = float3(0.5, 0.5, 0.5);
const float kPi = 3.1415926535897932384626433832795;

float grid(vec2 coord_m, float dots_per_m, float r_px) {
  float r = r_px / px_per_m;
  vec2 grid_coord = fract(coord_m * dots_per_m + 0.5) - 0.5;
  return smoothstep(r, r - 1 / px_per_m, length(grid_coord) / dots_per_m) * smoothstep(1. / (3 * r), 1. / (32 * r), dots_per_m);
}

// Should return a number between 0 and 1.
// It should return the ratio of the cell area below the given `pos`.
float vx(float2 pos, float a) {
  float l = 1.0 / sqrt(a * a + (1.0 - a) * (1.0 - a));
  float2 uv = pos * mat2x2(a, a - 1, 1 - a, a);
  uv = fract(uv * l) * 2 - 1; // -1 to 1
  float r2 = dot(uv, uv);
  if (r2 <= 1) {
    return kPi * r2 / 4;
  } else {
    return r2 * asin(1 / sqrt(r2)) + sqrt(r2 - 1) - kPi * r2 / 4;
  }
}

// performs a bright-style halftone dithering
vec3 halftone_bright(vec3 rgb, vec2 coord_px) {
  return vec3(
    (rgb.r + vx(coord_px, 0.12) / 3) >= 1 ? 1 : 0.66,
    (rgb.g + vx(coord_px, 0.34) / 3) >= 1 ? 1 : 0.66,
    (rgb.b + vx(coord_px, 0.69) / 3) >= 1 ? 1 : 0.66);
}

half4 main(vec2 coord_m) {
  // coord_m - a number from -0.5 to 0.5 - coordinate on the canvas, in metric space
  float dm_grid = grid(coord_m, 10, 2);
  float cm_grid = grid(coord_m, 100, 2) * 0.8;
  float mm_grid = grid(coord_m, 1000, 1) * 0.8;
  float d = max(max(mm_grid, cm_grid), dm_grid);

  float3 background_val = background_image.eval(coord_m + 0.5).rgb;

  // background dimensions are 1x1 m so if thre are more px in a meter than bg dimension, then we need to dither
  if (px_per_m > background_px) {
    float3 background_halftone = (
      halftone_bright(background_val.rgb, (coord_m + vec2(0.125, 0.375) / px_per_m) * background_px) +
        halftone_bright(background_val.rgb, (coord_m + vec2(0.375, -0.125) / px_per_m) * background_px) +
        halftone_bright(background_val.rgb, (coord_m + vec2(-0.125, -0.375) / px_per_m) * background_px) +
        halftone_bright(background_val.rgb, (coord_m + vec2(-0.375, 0.125) / px_per_m) * background_px)
      ) / 4;

    // halftone pattern appears at `background_px` and is in full effect at `background_px * 4`
    float halftone_blend = smoothstep(background_px, background_px * 4, px_per_m);

    background_val = mix(background_val, background_halftone, halftone_blend);
  }

  return vec4(mix(background_val, kDotsColor, d), 1);
}
