// kind=shader
//
// SPDX-FileCopyrightText: Copyright 2026 Automat Authors
// SPDX-License-Identifier: MIT
//
// Metal gear shape with twisting belt

uniform float iRotationRad;

uniform float iPixelRadius;
uniform float iGearCount;
uniform float iTeethAmplitudeCm;
uniform float iRadiusCm; // Radius of the "middle line" that goes through zero point of the gear sine wave

uniform float iGrooveStartCm;
uniform float iGrooveMiddleCm;
uniform float iGrooveEndCm;

uniform float iHoleRadiusCm;

uniform float iHoleRoundnessCm;

uniform vec2 iEndPos;

const float M_PI = 3.14159265358979323846;

// Metal color constants
const vec3 kMetalDark = vec3(0.25, 0.23, 0.22);
const vec3 kMetalMid = vec3(0.45, 0.42, 0.40);
const vec3 kMetalLight = vec3(0.65, 0.62, 0.58);
const vec3 kMetalBright = vec3(0.85, 0.82, 0.78);

float notch(float x, float left, float center, float right) {
  if (x > right || x < left) return 1;
  if (x < center)
    return smoothstep(center, left, x);
  return smoothstep(center, right, x);
}

float d_smoothstep(float edge0, float edge1, float x) {
  x = (x - edge0) / (edge1 - edge0);
  x = min(1, x);
  x = max(0, x);
  return 6 * x * (1 - x) * (edge0 - edge1);
}

float d_notch(float x, float left, float center, float right) {
  if (x > right || x < left) return 0;
  if (x < center)
    return d_smoothstep(center, left, x);
  return d_smoothstep(center, right, x);
}

float linramp(float edge0, float edge1, float x) {
  return (x - edge0) / (edge1 - edge0);
}

// Compute gear teeth height and surface gradients for normal computation
// x: radial distance from center
// angleRot: rotated angle * gear count (for teeth pattern)
// outerRadius: outer radius of the gear
// Outputs: h (height), dx (radial gradient), dy (tangential gradient)
void gearTeethSurface(vec2 uv_circ, float x, float angleRot, float outerRadius,
  out float h, out vec3 normal, out float alpha) {
  float r = iRadiusCm + iTeethAmplitudeCm * sin(angleRot);
  float sdf = min(r - x, x - iHoleRadiusCm);
  if (sdf <= 0.) {
    alpha = 0;
    return;
  }

  alpha = clamp(sdf / iPixelRadius / 100., 0., 1.);

  float margin = 0.1;

  h = 0.8 + 0.2 * sqrt(max(0., 1. - pow(x / outerRadius, 2.)));
  float dx = 0.2 * sin(x * M_PI / 2.);
  float dy = 0.;

  // Gear teeth edge
  float edge_dist = r - margin - x;
  if (edge_dist < 0.) {
    float mul = sqrt(max(0., 1. - pow(edge_dist / margin, 2.)));
    dx = dx * mul - h * sin(edge_dist / margin * M_PI / 2.);
    dy = h * -cos(angleRot) * (1. - mul);
    h *= mul;
  }

  // Hole edge roundness
  float hole_outer = iHoleRadiusCm + iHoleRoundnessCm;
  if (x < hole_outer) {
    float mul = sqrt(max(0., 1. - pow((x - hole_outer) / iHoleRoundnessCm, 2.)));
    dx = dx * mul + h * sin((x - hole_outer) / iHoleRoundnessCm * M_PI / 2.);
    h *= mul;
  }

  // Middle groove
  if (x > iGrooveStartCm && x < iGrooveEndCm) {
    float mul = 0.3 + 0.7 * notch(x, iGrooveStartCm, iGrooveMiddleCm, iGrooveEndCm);
    dx = dx * mul + h * 0.7 * d_notch(x, iGrooveStartCm, iGrooveMiddleCm, iGrooveEndCm);
    h *= mul;
  }

  h = max(h, 0.0);

  normal = vec3(
      uv_circ.x * dx - uv_circ.y * dy,
      uv_circ.y * dx + uv_circ.x * dy,
      sqrt(max(0., 1. - dx * dx)));
  normal = normalize(normal);
}

// Apply metal shading with full lighting model
// h: height value for AO and color variation
// normal: surface normal
// Returns: lit metal color
vec3 metalShade(float h, vec3 normal) {
  vec3 lightDir = normalize(vec3(0., 0.6, 0.8));
  vec3 viewDir = vec3(0., 0., 1.);
  vec3 halfDir = normalize(lightDir + viewDir);

  vec3 N = normalize(normal);
  float NdotL = max(dot(N, lightDir), 0.0);
  float diffuse = NdotL * 0.6 + 0.4;
  float NdotH = max(dot(N, halfDir), 0.0);
  float specular = pow(NdotH, 32.0) * 0.5;
  float NdotV = max(dot(N, viewDir), 0.0);
  float rim = pow(1.0 - NdotV, 2.0) * 0.3;
  float ao = smoothstep(-1., 1.0, h);

  vec3 baseColor = mix(kMetalDark, kMetalMid, smoothstep(0.0, 0.4, h));
  baseColor = mix(baseColor, kMetalLight, smoothstep(0.4, 0.8, h));

  vec3 color = baseColor * diffuse * ao;
  color += kMetalBright * specular;
  color += kMetalLight * rim;

  return color;
}

// Twist belt ray intersection
// Args:
//  theta - belt twist, from 0 (gear teeth visible from the side) to M_PI / 2 (tape visible)
//  y - distance from 0
//  hY - y value where gear teeth end
//  holeY - y value where gear teeth start
// Returns: bestFace (0 = tape, 1 = gears, -1 = miss)
// Outputs: localY (0-1 texture coordinate), bestNormal (surface normal)
void twistBelt(in float theta, in float y, in float hY, in float holeY, in float hZ,
  out float localY, out int bestFace, out vec3 bestNormal) {
  float c = cos(theta); // goes from flat 1 (near gear) to angled 0 (near tape)
  float s = sin(theta); // goes from angled 0 (near gear) to flat 1 (near tape)
  float cc = c * c; // goes from flat 1 (near gear) to flat 0 (near tape)
  float ss = s * s; // goes from flat 0 (near gear) to flat 1 (near tape)
  float sc = c * s; // goes from flat 0 (near gear) to flat 0 (near tape), with max = 0.5

  float tapeBottom = holeY - holeY * 2 * s;
  float tapeTop = holeY;
  if (y >= tapeBottom && y < tapeTop) {
    bestFace = 0;
    localY = (y - tapeBottom) / (tapeTop - tapeBottom);
    bestNormal = normalize(vec3(-sc, cc, ss));
    return;
  }
  float gearBottom = tapeTop;
  float gearTop = gearBottom + (hY - holeY) * c;
  if (y >= gearBottom && y < gearTop) {
    bestFace = 1;
    localY = (y - gearBottom) / (gearTop - gearBottom);
    bestNormal = normalize(vec3(sc, -1 + c, c));
    return;
  }

  bestFace = -1;
  bestNormal = vec3(0.0);
  localY = 0.0;
}

vec4 main(vec2 localCoord) {
  vec2 uv = localCoord * 100.; // scale coordinate system from metric, so that 1cm = 1

  vec2 end_pos_cm = iEndPos * 100.;
  vec2 end_dir = normalize(iEndPos);

  float tape = dot(end_dir, uv); // distance along the tape towards iEndPos
  if (tape > length(end_pos_cm)) {
    return vec4(0.);
  }

  float angle;
  if (tape > 0) {
    vec2 uv_circ = uv - tape * end_dir;
    angle = atan(uv_circ.y, uv_circ.x);
  } else {
    angle = atan(uv.y, uv.x);
  }
  float angleRot = (angle + iRotationRad) * iGearCount;
  float outerRadius = iRadiusCm + iTeethAmplitudeCm;

  // For tape > 0, we're in the twisting region
  if (tape > 0.) {
    // Belt cross-section dimensions (in cm)
    float outer_radius = iRadiusCm + iTeethAmplitudeCm; // Outer radius of gear
    float belt_width = iHoleRadiusCm; // Belt should be as wide as the hole is wide - looks nice

    // Twist angle: 0 at tape=0, PI/2 at tape=twist_length
    float twist_length = 1; // cm - length of the twist transition
    float theta = (0.5 - cos(clamp(tape / twist_length, 0., 1.) * M_PI) * 0.5) * M_PI / 2.;

    // y coordinate in the belt's local frame (perpendicular to tape direction)
    float tape_cross = end_dir.y * uv.x - end_dir.x * uv.y;

    float localY;
    int bestFace;
    vec3 tapeNormal;

    // Try both sides of the belt (positive and negative y)
    twistBelt(theta, tape_cross, outer_radius, iHoleRadiusCm, belt_width, localY, bestFace, tapeNormal);

    if (bestFace < 0) {
      twistBelt(theta, -tape_cross, outer_radius, iHoleRadiusCm, belt_width, localY, bestFace, tapeNormal);
      tape = -tape;
      tapeNormal.y = -tapeNormal.y;
    }

    // No hit - background
    if (bestFace < 0) {
      return vec4(0.);
    }

    // Rotate tapeNormal towards end_dir (along the z axis)
    tapeNormal *= mat3(
        end_dir.x, -end_dir.y, 0,
        end_dir.y, end_dir.x, 0,
        0, 0, 1
      );

    vec3 faceColor;
    float alpha = 1;

    if (bestFace == 0) {
      // Wide face (top/bottom) - debug red color
      faceColor = tapeNormal * 0.5 + 0.5;
    } else {
      // Thin face (sides) - procedural gear teeth pattern
      // Map localY (0-1) to radial position
      float radial_x = mix(iHoleRadiusCm, outer_radius, localY);

      // Compute angle-based gear teeth pattern from tape position
      // float belt_angle = tape * iGearCount / iRadiusCm + iRotationRad * iGearCount;
      angleRot += tape * iGearCount / iRadiusCm;

      // TODOs:
      // - change the UV shader into black rubber
      // - decide whether to remove twistBelt and replace it with a bunch of simpler sin-interpolations

      // Get gear teeth height for shading
      vec3 gearNormal;
      float h;
      gearTeethSurface(uv / outerRadius, radial_x, angleRot, outer_radius, h, gearNormal, alpha);

      // Rotate gearNormal by the rotation that takes (0,0,1) to tapeNormal
      vec3 zAxis = vec3(0, 0, 1);
      vec3 axis = cross(zAxis, tapeNormal);
      float c = dot(zAxis, tapeNormal);
      float s = length(axis);
      if (s > 0.001) {
        axis = axis / s;
        // Rodrigues rotation formula as a matrix
        mat3 K = mat3(
            0, axis.z, -axis.y,
            -axis.z, 0, axis.x,
            axis.y, -axis.x, 0
          );
        mat3 R = mat3(1) + s * K + (1.0 - c) * K * K;
        gearNormal = R * gearNormal;
      } else if (c < 0.0) {
        // tapeNormal is opposite to zAxis, flip
        gearNormal.z = -gearNormal.z;
      }

      // Apply metal shading with the combined normal
      faceColor = metalShade(h, gearNormal);
    }

    return vec4(faceColor, 1.0) * alpha;
  } else { // circular part of the gear
    float x = length(uv);

    float alpha;
    float h;
    vec3 normal;
    gearTeethSurface(uv / outerRadius, x, angleRot, outerRadius, h, normal, alpha);

    vec3 color = metalShade(h, normal);
    return vec4(color, 1.0) * alpha;
  }
}
