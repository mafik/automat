// kind=shader
//
// SPDX-FileCopyrightText: Copyright 2026 Automat Authors
// SPDX-License-Identifier: MIT
//
// Metal gear shape

uniform float iRotationRad;

uniform float iPixelRadius;
uniform float iGearCount;
uniform float iTeethAmplitudeCm;
uniform float iRadiusCm; // Radius of the "middle line" that goes through zero point of the gear sine wave

uniform float iGrooveStartCm;
uniform float iGrooveMiddleCm;
uniform float iGrooveEndCm;

uniform float iHoleRadiusCm;

uniform float iHoleRoundnessCm;

uniform vec2 iEndPos;

const float M_PI = 3.14159265358979323846;

float notch(float x, float left, float center, float right) {
  if (x > right || x < left) return 1;
  if (x < center)
    return smoothstep(center, left, x);
  return smoothstep(center, right, x);
}

float d_smoothstep(float edge0, float edge1, float x) {
  x = (x - edge0) / (edge1 - edge0);
  x = min(1, x);
  x = max(0, x);
  return 6 * x * (1 - x) * (edge0 - edge1);
}

float d_notch(float x, float left, float center, float right) {
  if (x > right || x < left) return 0;
  if (x < center)
    return d_smoothstep(center, left, x);
  return d_smoothstep(center, right, x);
}

vec4 main(vec2 localCoord) {
  vec2 uv = localCoord * 100; // scale coordinate system from metric, so that 1cm = 1

  vec2 end_pos_cm = iEndPos * 100;
  vec2 end_dir = normalize(iEndPos);

  float tape = dot(end_dir, uv);
  if (tape > length(end_pos_cm)) {
    return vec4(0, 0, 0, 0);
  }
  float tape_cross = end_dir.y * uv.x - end_dir.x * uv.y;
  float twist;

  vec2 uv_circ;
  if (tape > 0) {
    // Project all points onto the line perpendicular to end_pos_cm
    uv_circ = uv - dot(uv, end_pos_cm) / dot(end_pos_cm, end_pos_cm) * end_pos_cm;
    twist = 0.5 - cos(min(tape, 1) * M_PI) * 0.5;
  } else {
    uv_circ = uv;
    twist = 0;
  }

  // Compute h
  float angle = atan(uv_circ.y, uv_circ.x);
  float angleRot = (angle + iRotationRad) * iGearCount;
  float x = length(uv_circ);
  float hole_radius_cm = iHoleRadiusCm;
  float teeth_amplitude = iTeethAmplitudeCm;
  float margin = 0.1;
  float belt_width = iHoleRadiusCm;

  float h = 0.8 + 0.2 * sqrt(1 - pow(x, 2)); // rounded surface

  // Also compute the normals of the gear surface
  // Most of the formulas of the dx & dy were guessed based on looks and are probably not accurate.
  float dx = 0.2 * sin(x * M_PI / 2); // Normal along the radius
  float dy = 0; // Normal perpendicular to the radius

  // if (tape > 1) {
  //   if (x < belt_width) {
  //     return vec4(0, 0, 0, 1);
  //   } else {
  //     return vec4(0, 0, 0, 0);
  //   }
  // }
  if (tape > 0) {
    angleRot += tape * sign(tape_cross) * iGearCount / iRadiusCm;
    // float x_offset = (iHoleRadiusCm + iHoleRoundnessCm + belt_width) * twist;
    // x /= (1 - twist) * sign(tape_cross);
  }

  float r = iRadiusCm + teeth_amplitude * sin(angleRot);
  float sdf = min(r - x, x - hole_radius_cm); // approx, it's only used for AA so accuracy doesn't matter
  if (sdf <= 0) return vec4(0, 0, 0, 0);

  float alpha = clamp(sdf / iPixelRadius / 100, 0, 1);

  // gear teeth
  float edge_dist = r - margin - x;
  if (edge_dist < 0) {
    float mul = sqrt(1 - pow((edge_dist) / margin, 2));
    dx = dx * mul - h * sin((edge_dist) / margin * M_PI / 2);
    dy = h * -cos(angleRot) * (1 - mul); // certainly wrong but looks acceptable
    h *= mul;
  }

  float hole_outer = hole_radius_cm + iHoleRoundnessCm;
  if (x < hole_outer) { // center hole
    float mul = sqrt(max(0, (1 - pow((x - hole_outer) / iHoleRoundnessCm, 2))));
    dx = dx * mul + h * sin((x - hole_outer) / iHoleRoundnessCm * M_PI / 2);
    h *= mul;
  }

  if (x > iGrooveStartCm && x < iGrooveEndCm) { // middle groove
    float mul = 0.3 + 0.7 * notch(x, iGrooveStartCm, iGrooveMiddleCm, iGrooveEndCm);
    dx = dx * mul + h * 0.7 * d_notch(x, iGrooveStartCm, iGrooveMiddleCm, iGrooveEndCm);
    h *= mul;
  }

  h = max(h, 0.0);

  vec3 normal = vec3(
      cos(angle) * dx - sin(angle) * dy,
      sin(angle) * dx + cos(angle) * dy,
      sqrt(1 - pow(dx, 2)));
  normal = normalize(normal);

  // return vec4(normal * 0.5 + 0.5, 1) * alpha;

  // Metal gear shading

  vec3 lightDir = normalize(vec3(0, 0.6, 0.8));
  vec3 viewDir = vec3(0, 0, 1);
  vec3 halfDir = normalize(lightDir + viewDir);

  // Base metal colors (warm gray/brown tones from reference)
  vec3 metalDark = vec3(0.25, 0.23, 0.22); // Dark recesses
  vec3 metalMid = vec3(0.45, 0.42, 0.40); // Mid tones
  vec3 metalLight = vec3(0.65, 0.62, 0.58); // Highlights
  vec3 metalBright = vec3(0.85, 0.82, 0.78); // Bright specular

  // Normalize the normal
  vec3 N = normalize(normal);

  // Diffuse lighting (Lambert)
  float NdotL = max(dot(N, lightDir), 0.0);
  float diffuse = NdotL * 0.6 + 0.4; // Some ambient fill

  // Specular (Blinn-Phong)
  float NdotH = max(dot(N, halfDir), 0.0);
  float specular = pow(NdotH, 32.0) * 0.5;

  // Fresnel-like rim lighting - disabled because of weird normals
  float NdotV = max(dot(N, viewDir), 0.0);
  float rim = pow(1.0 - NdotV, 2.0) * 0.3;

  // Height-based ambient occlusion
  float ao = smoothstep(-1, 1.0, h);

  // Combine base color based on height and lighting
  vec3 baseColor = mix(metalDark, metalMid, smoothstep(0.0, 0.4, h));
  baseColor = mix(baseColor, metalLight, smoothstep(0.4, 0.8, h));

  // Apply lighting
  vec3 color = baseColor * diffuse * ao;
  color += metalBright * specular;
  color += metalLight * rim;

  return vec4(color, 1.0) * alpha;
}
