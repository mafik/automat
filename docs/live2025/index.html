<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automat: Objects As Syntax Not Data</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Andika:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <article>
        <h1>Automat: Objects As Syntax Not Data</h1>
        <h2>Abstract</h2>
        <p>Automat is a skeuomorphic desktop automation tool (similar in function to AutoHotKey) with the end-goal of
            evolving into a fast & intuitive general purpose computing environment. This article aims to give an
            overview of Automat, focusing on it's distinguishing approach to object-oriented programming.</p>

        <p>Automat's notion of objects (called Syntax Objects) are a materialization of programming abstractions.
            They should be applicable to other programming environments and should become a valuable tool for programming
            language researchers and software engineers.</p>

        <h2>Introduction to Automat</h2>
        <p>Computers have a potential to greatly improve people's lives. By automating repeatable work. By providing
            access to the humanity's combined knowledge & culture. By amplifying human creativity with innovative
            digital tools.</p>

        <p>Yet existing software ecosystem largely fails to realize this potential. Forces that surround software
            engineering seem to eventually separate users & programmers, locking out a large portion of the population
            from commanding computers. One source of these forces lies in poor, inconsistent or obsolete decisions made
            when the foundational technologies have been designed. Another source, maybe the more important out of the
            two, lies in social barriers that limit the access to knowledge, often in subtle and hard to see ways.</p>

        <p>Luckily we're seeing continued progress on both fronts. Growth of internet, smartphones and large language models
            in the last few decades inspire great optimism in more egalitarian access to technology in the future.</p>

        <p>This work aims to further this goal by reducing the formalism required to control computers. It introduces an
            environment called Automat - an interface offering a skeuomorphic representation of objects in computer
            memory.</p>

        <style>
            .caption {
                font-size: .9em;
                margin-top: 0;
                margin-bottom: 20px;
                text-align: center;
            }
        </style>

        <video class="figure" controls autoplay loop muted>
            <source src="example1.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>

        <div class="caption">A stack of three objects - Window Capture, Tesseract OCR and a Timer.
            The objects are connected in sequence.
            First Window Capture captures a window.
            Then Tesseract OCR analyzes its contents.
            Finally a timer waits for one second and loops back to the beginning. </div>

        <p>Metaphorical interface allows a wider audience of users to compose complex behaviors. People who see
            themselves as "non-technical" are not alienated by formal appearance. People who are not familiar with
            computer terminology can guess the function and composition rules of on-screen elements. It invites playful
            experimentation.</p>

        <p>Initial goal of Automat is set on the problem of game automation. Games provide entertainment, enrich social life and
            serve as a powerful tool for learning and sharpening skills. Unfortunately many modern computer
            games, particularly the ones developed with return on investment in mind, adopt a range of techniques that
            produce addiction and incentivise recurring payments.
            Mechanisms such as virtual resource gathering, randomized rewards, classical conditioning through repetition,
            stimulus & reward are a common element of many games.</p>

        <p>The opportunity that Automat sees in this environment is that game automation may offer a way to break free from
            addictive gameplay loops, while simultaneously allowing players to engage with the game on a deeper,
            more strategic level.</p>

        <p>From the perspective of Automat's development, the variety of games creates a smooth complexity gradient -
            which makes it usable very early in its development as a macro playback utility with incremental additions
            expanding its use to more use-cases. Eventually, the same techniques that can be used for game automation
            may potentially be used to solve real-world problems, transitioning Automat into a general purpose computing
            environment.</p>

        <p>Learning from programming languages which are in broad use today, Automat's development is not being done
            with expectation of profit. Monetization efforts tend to compromise the design of computing environments by
            introducing competing objectives. As a result commercial programming systems have had a history of
            difficulties in attracting user trust. Instead, Automat's development is driven by a small community
            following hacker culture & hacker ethics. The goal of this article is to encourage readers to join this
            community and push the frontier of visual programming <span data-footnote="invitation">together</span>.</p>

        <p id="invitation" class="footnote">The easiest way to join is to reach out through real-time chat at <a href="https://automat.org/gang" target="_blank">automat.org/gang</a>.
            Feel free to join our community to follow the project's progress.
            For those wishing to contribute, we encourage you to introduce yourself along with your relevant skills or interests.
            Automat welcomes a wide range of expertise, from playtesters to sound designers and everything in between.
        </p>

        <p>Just like many tools in the physical world are designed with two "ends" in mind - one meant for being
            comfortable in human hand - and one efficient at doing the work. Automat's design has three "ends".</p>

        <ul>
            <li>One meant for interfacing with the person using the system,</li>
            <li>one meant for interoperability with other tools and</li>
            <li>one meant for effectively utilizing the computing hardware.</li>
        </ul>

        <p>This article focuses on the first of the three.</p>

        <h2>Objects As Syntax Not Data</h2>

        <p>Automat's design is based on the idea that programmers working with
            a program build a mental representation of the program, composed of <span data-footnote="naur">interacting abstract objects</span>.</p>

        <p id="naur" class="footnote">Not all programmers subscribe to this view. Notably <a href="https://pages.cs.wisc.edu/~remzi/Naur.pdf">Programming as
                Theory Building by Peter Naur</a> distances itself from it: <q>(...) a theory held by a
                person has no inherent division into parts and no inherent ordering.</q>
            Instead it adopts a more scientific, behavioral definition of theory: as the ability to answer questions and make changes to the program.
        </p>

        <p>Note that this usage of "abstract objects" has nothing to do with classical OOP terminology. Instead, the term comes from
            philosophical conceptualism, which argues that a thinking mind generalizes knowledge through universals, which exist within
            the mind as abstract objects. While most universals are closely connected to linguistic terms and are easy to communicate,
            domain experts over time can develop their own set of abstract objects. Think of a mathematician examining a mathematical
            problem or a chess player planning a strategy.</p>

        <p>Within the field of software engineering these abstract objects are commonly called <em>abstractions</em> and are fundamental
            to high-level programming languages and software architecture.</p>

        <p>Abstractions in a computer program typically map to subgraphs of the abstract syntax tree. They may also exist
            within the code implicitly as invariants, or imagined results of code execution at its different stages.</p>

        <p>Programmers use a term "readability" for programs where abstractions are evident from the source code. Conversely,
            the practice of obfuscation makes programs harder to understand by <q>breaking abstractions</q> while preserving program behavior.</p>

        <p>We can attempt to translate objects from this abstract mental domain back into a concrete computing environment
            where each abstract object is materialized as concrete and composable object on the screen of a computer.
            We will call the objects produced by this translation <em>Syntax Objects</em>.</p>

        <h3>Novelty</h3>

        <p>Syntax Objects are a new term for real counterpart of a concept known within software engineering as <em>abstractions</em>.</p>

        <p>Within the context of software engineering, the contribution of this article is that it:</p>
        <ol>
            <li>defines the category of Syntax Objects as a materialization of abstractions,</li>
            <li>identifies some of the properties of Syntax Objects that are helpful in their design,</li>
            <li>proposes a set of programmer-centric design objectives for Syntax Objects.</li>
        </ol>

        <h3>Example</h3>

        <img id="bash" class="figure" src="bash.png" style="max-width: 100%; box-shadow: none">
        <div class="caption">Syntax Objects in Bash</div>

        <p>Syntax Objects can be found in every high level programming system. Many of them are provided by the programming language
            through its syntax and standard library but programmers often roll out their own through user-defined functions,
            classes and macros.</p>

        <h3>Properties</h3>

        <p>Since the size of the source code for any problem is constant, regardless of the size of the processed data,
            then a round-trip translation of any program from its formal definition into abstractions and then
            back into Syntax Objects should produce a constant number of the latter.
            This means that <em>the number of Syntax Objects for any given program is constant</em>.</p>

        <p>Just like variables and unlike traditional OOP objects, Syntax Objects are not data themselves. Instead they
            form an interface to data. Syntax Objects are typically not automatically constructed &
            destroyed <span data-footnote="macros">during program execution</span>.</p>

        <p id="macros" class="footnote">One exception to this may be programs that employ macro expansion,
            rule-based substitutions or polymorphic code during their execution.</p>

        <p>Just like user-defined functions with their call sites and a definition, Syntax Objects are mental primitives (atoms)
            from the perspective of the programmer solving one specific problem but within the system their behavior
            may be arbitrarily complex and open for change. This means that the <em>atomicity of Syntax Objects is relative</em>.</p>

        <p>A concrete bound for the number of interacting Syntax Objects may be estimated from the psychological studies of the working memory.
            <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_blank">The Magical Number Seven, Plus or Minus Two</a> by George Miller,
            suggests that a working memory can only hold about 7 distinct chunks of information <span data-footnote="deutsch">at once</span>.
        </p>

        <p id="deutsch" class="footnote">A limit that may prove helpful in managing visual complexity. A known weak point of visual programming environments, summarized in a statement called the Deutsch
            limit: <q>The problem with visual programming is that you can't have more than 50 visual primitives on the screen
                at the same time.</q></p>

        <p>Similarly to program source code, Syntax Objects may either perform their work through interpretation or be translated
            into a more efficient form through compilation.</p>

        <h3>Design Criteria</h3>

        <p>The starting point for designing Syntax Objects is their mapping to mental devices that programmers use when thinking about programs.
            By providing an interface that resembles and supports those mental contructs,
            both experienced and novice programmers can work faster and more intuitively.
            Syntax Objects are the area within programming where <span data-footnote="design">careful design</span> is most
            needed.</p>

        <p id="design" class="footnote">A brief introduction to the role of design can be found in <a href="https://www.andrewcoyle.com/blog/beauty-is-objective">Beauty Is Objective</a> by Andrew Coyle.
            Although written with website design in mind, this introduction is very applicable to programming environments.
            In fact it is recommended to interrupt this lecture now to read that article.</p>

        <p>We can outline some objectives for a well designed Syntax Object:</p>

        <p><em>Faithful</em>. Elementary operations offered by a Syntax Object should correspond to the transforms that programmers
            perform when thinking about a program.</p>

        <p><em>Discoverable</em>. When a programmer needs a specific Syntax Object but is not aware of its existence, it should be
            easy to find it.</p>

        <p><em>Memorable</em>. A programmer who used specific Syntax Object in the past should have an easy time recalling it when
            needed.</p>

        <p><em>Skimmable</em>. Programmers (including programmers without formal education) should be able to
            intuitively guess the function of a Syntax Object in the first seconds of seeing it for the first time.</p>

        <p><em>Easy to master</em>. Fully understanding the behavior of a Syntax Object should require as little effort as
            possible.</p>

        <p><em>Fast to use</em>. Time needed to perform a task using a given Syntax Object should be minimized.</p>

        <p>Many other design objectives could be listed here but only the ones directly related to the
            programmer have been deemed <span data-footnote="relevant">relevant</span>.</p>

        <p id="relevant" class="footnote">Syntax Objects can also facilitate interoperability and efficiency but these are not the focus of this article.</p>

        <p><em>Exercise:</em> It's valuable to go back to the <a href="#bash">bash example</a> above. Please take a a
            look at that
            example now and try to answer the following questions:</p>
        <ol>
            <li>How would you rate the Bash programmer interface in each of the design criteria listed in this section?
            </li>
            <li>Try to imagine an alternative interface that would aim to maximize each out of those design criteria.
                Focus on just one criterion at a time. How could this interface look like?</li>
        </ol>

        <p>Following the first two points should make it clear to the reader how Syntax Objects differ from objects used at
            program runtime and that they need to be designed with a different mindset.</p>

        <h2>Objects In Automat</h2>
        <p>Automat uses careful Syntax Object design to enable its users to perform tasks typically reserved to professional
            programmers.</p>

        <h3>Machine Code Scripting</h3>
        <p>An example of this approach is a scripting mechanism used by Automat. Automat's scripts use a metaphor of
            playing cards with instructions written on them, similar to many collectible card games. Each card
            corresponds roughly to one machine instruction and can be composed with other cards to form a program. CPU
            registers are presented visually as checkerboards governed by an icon. Iconic representation helps avoid
            jargon and makes the representation more welcoming. The instruction cards don't fully hide their low-level
            nature - they still show the assembly mnemonic & machine code in the corners of the card - but they do so in
            a way that passes as visual ornament rather than the main interface.</p>

        <img class="figure" src="instruction.png" style="max-width: 100%; box-shadow: none">
        <div class="caption">Instruction cards in Automat</div>

        <p>While this representation can be used by non-technical users, it also produces scripts that execute with the
            performance of hand-crafted assembly.</p>

        <p>Thanks to closeness of mapping, this representation also enables hot code reloading where the user may freely
            change the code while it's executing.</p>

        <video class="figure" controls autoplay loop muted>
            <source src="machine_code.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>

        <div class="caption">Machine code instructions in Automat</div>

        <h3>Programming By Demonstration</h3>
        <p>The basic function of Automat is recording & replaying input macros. A simple macro can be created by
            creating a chain of simple commands & delays:</p>

        <video class="figure" controls autoplay loop muted>
            <source src="simple_macro.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>

        <div class="caption">Imperative-style macro for sending "left mouse down" and "left mouse up" events with
            controllable delays</div>

        <p>While it's fairly easy for simple cases, this approach fails for more complex sequences of keystrokes.
            Programming them manually would be prohibitively slow. To help with that, Automat offers several helpers:
        </p>

        <ul>
            <li>a Macro Recorder object that records keystrokes,</li>
            <li>a Hotkey object that triggers execution of other objects when a hotkey is pressed and</li>
            <li>a Timeline object that can drive execution of other objects according to its tracks.</li>
        </ul>

        <p>Together they can be used to create an ad-hoc programming-by-demonstration environment:</p>

        <video class="figure" controls autoplay loop muted>
            <source src="macro_recorder.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>

        <div class="caption">A typical setup for recording macros in Automat</div>

        <p>Together with other objects present in Automat this enables users to mix different programming
            techniques - procedural programming, reactive programming, programming by demonstration.</p>

        <h2>Summary</h2>
        <p>We have defined Programmer Interface Objects - a category of objects that are used by programmers to
            construct programs. As opposed to classical OO objects which encapsulate data & behavor during program
            runtime, Syntax Objects form the human-computer interface of a programming environment. Because of their different role,
            Syntax Objects should be separated from runtime data structures and designed with different objectives in mind.</p>

        <p>An example of the Automat environment demonstrates that carefully designed Syntax Objects can enable non-programmers
            to perform tasks typically reserved to expert programmers - such as manipulating low-level machine code and
            mixing different programming styles.</p>

        <details style="display: none;">
            <summary class="h2">
                Appendix: Relation of Syntax Objects to Object-Oriented Programming
            </summary>

            <p>The relation to OOP is worth discussing in more detail.</p>

            <p>TODO: OOP is largely concerned with binding code to data which is orthogonal to the idea of syntax objects (syntax objects lifetime is static)</p>

            <p>TODO: HOWEVER, programmers can (and do) define their own SOs using OOP tools. Keep in mind that design objectives for SOs are different from runtime objects (for example SOLID principles).</p>

        </details>

    </article>

    <script>
        function ToggleFootnote(event) {
            const anchor = event.currentTarget;
            const noteId = anchor.dataset.footnote;
            const note = document.getElementById(noteId);
            note.classList.toggle("open");
            event.stopPropagation();
        }
        document.addEventListener("DOMContentLoaded", () => {
            const anchors = document.querySelectorAll("[data-footnote]");
            anchors.forEach(anchor => {
                anchor.addEventListener("click", ToggleFootnote);
            });
        });
    </script>
</body>

</html>